import { doc, setDoc, getDoc, collection, updateDoc, query, getDocs, serverTimestamp, runTransaction } from 'firebase/firestore';
import { db } from '../../../utils/firebaseConfig';
import { createUserFolderStructure } from '../../files/services/fileService';
import { MEMBERSHIP_PLANS } from '../../membership/services/membershipService';

export async function generateUserId() {
    console.warn('[userService] generateUserId is deprecated. ID is now generated by Backend (/users/init).');
    return null; 
}

export async function createUserProfile(userData, membershipPlan = 'free') {
    const userId = userData.uid;
    const userEmail = userData.email;
    const userName = userData.displayName || userEmail.split('@')[0];
    const uniqueUserId = await generateUserId();

    const now = new Date();
    const planDetails = MEMBERSHIP_PLANS[membershipPlan.toUpperCase()];
    const expiryDate = planDetails?.duration !== 'unlimited' ? new Date(now.getTime() + (30 * 24 * 60 * 60 * 1000)) : null;

  /* 
       SECURITY UPDATE: 
       Frontend does NOT write 'role'.
       Role is assigned by Backend via /users/init or Cloud Function.
    */
    const userProfile = {
        email: userEmail,
        displayName: userName,
        userId, uniqueUserId,
        // role: 'user', // <--- REMOVED: Managed by Backend
        accountCreatedAt: serverTimestamp(),
        accountCreatedDate: now.toISOString(),
        lastLoginAt: serverTimestamp(),
        /* 
           MEMBERSHIP UPDATE:
           Frontend does NOT write 'membership'.
           Default 'Free' plan is assigned by Backend via /users/init.
        */
        // membership: { ... }, // <--- REMOVED: Managed by Backend
        usage: {
            totalChats: 0, totalMessages: 0, totalFilesUploaded: 0,
            storageUsedMB: 0, monthlyQuotaUsed: 0, lastResetDate: now.toISOString()
        },
        settings: { notifications: true, emailUpdates: true, dataRetention: true }
    };

    await setDoc(doc(db, 'users', userId), userProfile);
    await createUserFolderStructure(userId, userName);
    
    // Call Backend to initialize secure fields (Role)
    try {
        const token = await userData.getIdToken();
        // Assuming API_URL is accessible or we use a relative path if proxied. 
        // Using fetch to avoid circular deps if axios is not set up in this service file alone.
        // We need the API URL. Let's try to get it from env or hardcode fallback relative to where frontend expects.
        // Usually VITE_API_URL.
        const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000';
        
        await fetch(`${apiUrl}/users/init`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        });
        console.log('[userService] Backend initialized user role.');
    } catch (e) {
        console.error('[userService] Failed to call backend init:', e);
        // Does not block flow, but warns. Backend will eventually catch it on next login if we check there too.
    }

    return userProfile;
}

export async function updateUserUsage(userId, updates) {
    console.warn('[userService] updateUserUsage is deprecated. Usage is now tracked on the backend.');
    // Function disabled for security.
}

export async function updateUserLastLogin(userId) {
    try {
        await updateDoc(doc(db, 'users', userId), { lastLoginAt: serverTimestamp() });
    } catch { /* silent */ }
}

export async function assignUserIdToExistingUser(userId, userData) {
    try {
        if (userData.uniqueUserId) return userData.uniqueUserId;
        const uniqueUserId = await generateUserId();
        await updateDoc(doc(db, 'users', userId), { uniqueUserId, updatedAt: serverTimestamp() });
        return uniqueUserId;
    } catch { return null; }
}

export async function ensureUserHasId(userId) {
    try {
        const userDocRef = doc(db, 'users', userId);
        const userDoc = await getDoc(userDocRef);
        
        if (!userDoc.exists()) {
             // console.warn...
             return null;
        }

        const userData = userDoc.data();
        if (userData.uniqueUserId) {
            return userData.uniqueUserId;
        }

        console.log('[ensureUserHasId] uniqueUserId missing. Delegating to Backend...');
        // We do NOT write to DB here. 
        return null;
    } catch (error) {
        console.error('[ensureUserHasId] Error accessing user doc:', error);
        return null;
    }
}

export async function getUserRole(userId) {
    try {
        const userData = await getUserData(userId);
        if (!userData) return 'user';
        const role = userData.role || 'user';
        return role === 'super_admin' ? 'superadmin' : role;
    } catch { return 'user'; }
}

export async function getUserData(userId) {
    try {
        const userDoc = await getDoc(doc(db, 'users', userId));
        return userDoc.exists() ? userDoc.data() : null;
    } catch { return null; }
}
